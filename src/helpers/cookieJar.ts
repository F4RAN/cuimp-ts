import fs from 'fs'
import path from 'path'
import os from 'os'
import type { CookieJarOption } from '../types/cuimpTypes'

/**
 * Manages cookie storage for curl-impersonate requests.
 * Uses curl's native cookie file format (Netscape format).
 */
export class CookieJar {
  private cookieFilePath: string
  private isTemporary: boolean
  private initialized: boolean = false

  constructor(option: CookieJarOption) {
    if (typeof option === 'string') {
      // User provided a custom path
      this.cookieFilePath = option
      this.isTemporary = false
    } else {
      // Create a temporary file in the system temp directory
      const tempDir = path.join(os.tmpdir(), 'cuimp-cookies')
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true })
      }
      // Use a unique filename based on timestamp and random string
      const uniqueId = `${Date.now()}-${Math.random().toString(36).substring(2, 9)}`
      this.cookieFilePath = path.join(tempDir, `cookies-${uniqueId}.txt`)
      this.isTemporary = true
    }
  }

  /**
   * Initialize the cookie file if it doesn't exist
   */
  private ensureFileExists(): void {
    if (this.initialized) return

    // Create the directory if it doesn't exist
    const dir = path.dirname(this.cookieFilePath)
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true })
    }

    // Create an empty file if it doesn't exist
    if (!fs.existsSync(this.cookieFilePath)) {
      // Write Netscape cookie file header
      fs.writeFileSync(
        this.cookieFilePath,
        '# Netscape HTTP Cookie File\n# https://curl.se/docs/http-cookies.html\n# This file was generated by cuimp\n\n'
      )
    }

    this.initialized = true
  }

  /**
   * Get the path to the cookie file
   */
  getFilePath(): string {
    this.ensureFileExists()
    return this.cookieFilePath
  }

  /**
   * Get curl arguments for cookie handling
   * -b: Read cookies from file
   * -c: Write cookies to file
   */
  getCurlArgs(): string[] {
    const filePath = this.getFilePath()
    return ['-b', filePath, '-c', filePath]
  }

  /**
   * Clear all cookies by emptying the cookie file
   */
  clear(): void {
    if (fs.existsSync(this.cookieFilePath)) {
      fs.writeFileSync(
        this.cookieFilePath,
        '# Netscape HTTP Cookie File\n# https://curl.se/docs/http-cookies.html\n# This file was generated by cuimp\n\n'
      )
    }
  }

  private isLineComment(line: string): boolean{
    if(line.startsWith("#HttpOnly_")) return false
    else if(line.startsWith("#")) return true
    return false
  }

  /**
   * Get all cookies as raw text (Netscape format)
   */
  getCookiesRaw(): string {
    if (!fs.existsSync(this.cookieFilePath)) {
      return ''
    }
    return fs.readFileSync(this.cookieFilePath, 'utf8')
  }

  private domainCleaner(domain: string): string{
    let cleanDomain = domain
    cleanDomain = cleanDomain.replace("#HttpOnly_", "")
    // Future rules
    return cleanDomain
  }

  /**
   * Parse cookies from the file into an array of cookie objects
   */
  getCookies(): Array<{
    domain: string
    includeSubdomains: boolean
    path: string
    secure: boolean
    expires: number
    name: string
    value: string
  }> {
    const raw = this.getCookiesRaw()
    const lines = raw.split('\n')
    const cookies: Array<{
      domain: string
      includeSubdomains: boolean
      path: string
      secure: boolean
      expires: number
      name: string
      value: string
    }> = []

    for (const line of lines) {
      // Skip comments and empty lines
      if (this.isLineComment(line) || line.trim() === '') {
        continue
      }

      // Netscape format: domain\tinclude_subdomains\tpath\tsecure\texpires\tname\tvalue
      const parts = line.split('\t')
      if (parts.length >= 7) {
        cookies.push({
          domain: this.domainCleaner(parts[0]),
          includeSubdomains: parts[1] === 'TRUE',
          path: parts[2],
          secure: parts[3] === 'TRUE',
          expires: parseInt(parts[4], 10),
          name: parts[5],
          value: parts[6],
        })
      }
    }

    return cookies
  }

  /**
   * Get cookies for a specific domain
   */
  getCookiesForDomain(domain: string): Array<{
    name: string
    value: string
  }> {
    const allCookies = this.getCookies()
    const now = Math.floor(Date.now() / 1000)

    return allCookies
      .filter(cookie => {
        // Check if cookie is expired (0 means session cookie)
        if (cookie.expires !== 0 && cookie.expires < now) {
          return false
        }

        // Check domain match
        if (cookie.includeSubdomains) {
          return domain.endsWith(cookie.domain) || domain === cookie.domain.replace(/^\./, '')
        }
        return domain === cookie.domain || domain === cookie.domain.replace(/^\./, '')
      })
      .map(cookie => ({
        name: cookie.name,
        value: cookie.value,
      }))
  }

  /**
   * Set a cookie manually (writes to the cookie file)
   */
  setCookie(options: {
    domain: string
    path?: string
    secure?: boolean
    expires?: number | Date
    name: string
    value: string
    includeSubdomains?: boolean
  }): void {
    this.ensureFileExists()

    const expiresTimestamp = options.expires
      ? options.expires instanceof Date
        ? Math.floor(options.expires.getTime() / 1000)
        : options.expires
      : 0 // 0 means session cookie

    const line = [
      options.domain.startsWith('.') ? options.domain : `.${options.domain}`,
      options.includeSubdomains !== false ? 'TRUE' : 'FALSE',
      options.path || '/',
      options.secure ? 'TRUE' : 'FALSE',
      expiresTimestamp.toString(),
      options.name,
      options.value,
    ].join('\t')

    fs.appendFileSync(this.cookieFilePath, line + '\n')
  }

  /**
   * Delete cookies by name (optionally filtered by domain)
   */
  deleteCookie(name: string, domain?: string): void {
    const raw = this.getCookiesRaw()
    const lines = raw.split('\n')
    const filteredLines = lines.filter(line => {
      if (this.isLineComment(line) || line.trim() === '') {
        return true // Keep comments and empty lines
      }
      const parts = line.split('\t')
      if (parts.length >= 7) {
        const cookieName = parts[5]
        const cookieDomain = this.domainCleaner(parts[0])
        if (cookieName === name) {
          if (domain) {
            return cookieDomain !== domain && cookieDomain !== `.${domain}`
          }
          return false // Delete all cookies with this name
        }
      }
      return true
    })

    fs.writeFileSync(this.cookieFilePath, filteredLines.join('\n'))
  }

  /**
   * Clean up the cookie file (for temporary files)
   */
  destroy(): void {
    if (this.isTemporary && fs.existsSync(this.cookieFilePath)) {
      try {
        fs.unlinkSync(this.cookieFilePath)
      } catch {
        // Ignore errors during cleanup
      }
    }
  }

  /**
   * Check if the cookie jar is using a temporary file
   */
  isTemp(): boolean {
    return this.isTemporary
  }
}
